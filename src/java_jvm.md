1.程序计数器
    程序计数器是一块较小的内存空间,它可以看作是当前线程所执行的字节码行号指示器.在虚拟机的概念模型里,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复等基础功能
都需要依赖这个计数器来完成.
    由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器都只会执行一条线程中的指令.因此,为了线程切换后能回到正确的执行位置,每个线程都需要有一个独立的程序计数器,各条线
程之间计数器互不影响,独立存储,称这类内存区域为"线程私有"的内存.
    如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是Native方法,这个计数器值则为空.此内存区域没有OutOfMemoryError情况.
2.虚拟机栈
    虚拟机栈是线程私有的,它的生命周期与线程相同.虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时会创建一个栈帧(Stack Frame)用于存储局部变量表,操作数栈,动态链接,方法出口等信息.每一个方法从调用直至执行完成的过
程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程.
    局部变量表存放了编译期可知的各种基本数据类型(boolean(1字节),byte(1字节),char(2字节),short(2字节),int(4字节),long(8字节),float(4字节),double(8字节)),对象引用(reference类型,它不等同于对象本身,可能是一个指向对象起始地址的引用指针,也可能是指向一个代表对象的句柄或其他
与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址).
    这个区域有两种异常状况:如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常;如果虚拟机栈可以动态扩展的,扩展时无法申请到足够的内存,就会抛出OutOfMemoryError异常.
3.本地方法栈
    本地方法栈与虚拟机栈所发挥的作用类似,它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务,而本地方法栈则为虚拟机使用的Native方法服务.也会抛出StackOverflowError和OutOfMemoryError异常.
4.堆
    堆(Heap)是Java虚拟机所管理的内存中最大的一块.Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存.
    堆是垃圾收集器管理的主要区域,因此很多时候也被称为GC堆,从内存回收的角度来看,由于现在的收集器基本都采用分代收集算法,所以堆中还可以细分为:新生代和老年代:再细致一点的有Eden空间,From Survivor空间,To Survivor空间等.如果
堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError.
5.方法区
    方法区与堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息,常量,静态变量
                                